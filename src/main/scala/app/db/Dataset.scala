/*
 active-learning-scala: Active Learning library for Scala
 Copyright (c) 2014 Davi Pereira dos Santos

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package app.db

import java.io.File
import java.sql.{Connection, DriverManager}

import al.strategies.{RandomSampling, Strategy}
import app.ArgParser
import org.apache.commons.io.FileUtils
import util.{ALDatasets, Datasets}

import scala.collection.mutable
import scala.util.Random

/**
 * Cada instancia desta classe representa uma conexao a
 * um arquivo db, ou seja, um dataset.
 * Uma vez aberta, a conexao aceita consultas simultaneas
 * que sao resolvidas pelo SQLite.
 * É preciso fechar a conexão para que o arquivo seja
 * copiado de volta para seu local de origem.
 * O programa é interrompido (espera-se) caso mais de
 * uma conexão seja tentada no mesmo arquivo.
 */
case class Dataset(path: String)(dataset: String) {
  //Lock
  private val rnd = new Random(10)
  private var available = true

  private def acquire = {
    Thread.sleep((rnd.nextDouble() * 100).toInt)
    synchronized {
      while (!available) wait()
      available = false
    }
  }

  private def release = {
    Thread.sleep((rnd.nextDouble() * 100).toInt)
    synchronized {
      available = true
      notify()
    }
  }

  private val dbOriginal = new File(path + dataset + ".db")
  private val dbCopy = new File("/tmp/" + dataset + ".db")
  if (dbCopy.exists()) {
    println(dbCopy + " já existe! Talvez outro processo esteja usando " + dbOriginal + ".")
    sys.exit(0)
  }
  if (!dbOriginal.exists()) {
    println(dbOriginal + " não existe! Talvez seja preciso rodar o conversor ARFF -> SQLite.")
    sys.exit(0)
  }
  private var connection: Connection = null

  def open(debug: Boolean = false) {
    try {
      FileUtils.copyFile(dbOriginal, dbCopy)
      Class.forName("org.sqlite.JDBC")
      val url = "jdbc:sqlite:////" + dbCopy
      connection = DriverManager.getConnection(url)
    } catch {
      case e: Throwable => e.printStackTrace
        println("\nProblems opening db connection: " + dbCopy + ":")
        println(e.getMessage)
        sys.exit(0)
    }
    if (debug) println("Connection to " + dbCopy + " opened.")
    //    println("Attaching App dataset...")
    val appPath = ArgParser.appPath
    try {
      val statement = connection.createStatement()
      statement.executeUpdate("attach '" + appPath + "app.db' as app")
    } catch {
      case e: Throwable => e.printStackTrace
        println("\nProblems Attaching " + appPath + ".")
        sys.exit(0)
    }
    //    println(" Dataset " + appPath + "app.db attached!")
  }

  /**
   * Inserts query-tuples (run, fold, position, instid) into database.
   * All queries for a given pair run-fold should be written at once.
   * The original file is updated at the end.
   * If the given pair run/fold already exists, nothing is done.
   *
   * Generates only Q queries from the provided strategy,
   * unless Q is not given (in this case all possible queries (the entire pool) will be generated).
   *
   * Returns the number of queries generated by the strategy.
   */
  def writeQueries(strat: Strategy, run: Int, fold: Int, Q: Int = Int.MinValue) = {
    if (connection == null) {
      println("Impossible to get connection to write queries at the run " + run + " and fold " + fold + " for strategy " + strat + ". Isso acontece após uma chamada a close() ou na falta de uma chamada a open().")
      sys.exit(0)
    }

    //Fetch StrategyId by name.
    var stratId = -1
    try {
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("select rowid from app.strategy where name='" + strat + "'")
      resultSet.next()
      stratId = resultSet.getInt("rowid")
    } catch {
      case e: Throwable => e.printStackTrace
        println("\nProblems inserting queries into: " + dbCopy + ".")
        sys.exit(0)
    }
    //    println("Strategy " + strat + " has id " + stratId + ".")

    //Check if the job was already done before.
    //It assumes that there is no inconsistency like a partial job/half transactions (e.g. half of the queries) registered in dataset.
    var alreadyDone = false
    var q = -1
    try {
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("select count(rowid) as q from query where strategyid=" + stratId + " and run=" + run + " and fold=" + fold)
      resultSet.next()
      q = resultSet.getInt("q")
      if (q > 0) {
        alreadyDone = true
        if (q < Q) {
          println("Not enough queries (" + q + ") fetched from dataset " + dbCopy + " for run=" + run + " and fold=" + fold + ". Required: " + Q)
          sys.exit(0)
        }
      }
    } catch {
      case e: Throwable => e.printStackTrace
        println("\nProblems looking for preexistence of queries in: " + dbCopy + ".")
        sys.exit(0)
    }

    //Insert Q (or all) queries.
    if (!alreadyDone) {
      val Qtaken = if (Q == Int.MinValue) Int.MaxValue else Q
      val seq = strat.queries.take(Qtaken).map(_.id).toVector
      q = seq.length
      acquire
      try {
        val statement = connection.createStatement()
        statement.executeUpdate("begin")
        seq.zipWithIndex.foreach { case (paId, idx) => statement.executeUpdate("insert into query values (" + stratId + "," + run + "," + fold + "," + idx + "," + paId + ")")}
        statement.executeUpdate("end")
      } catch {
        case e: Throwable => e.printStackTrace
          println("\nProblems inserting queries into: " + dbCopy + ":")
          println(e.getMessage)
          println("Deleting " + dbCopy + "...")
          dbCopy.delete()
          println(" " + dbCopy + " deleted!")
          sys.exit(0)
      }
      println(q + " queries written to " + dbCopy + ". Backing up tmpFile...")
      copyDb
      release
    }
    q
  }

  def run(sql0: String) = {
    val sql = sql0.toLowerCase()
    if (connection == null) {
      println("Impossible to get connection to apply sql query " + sql + ". Isso acontece após uma chamada a close() ou na falta de uma chamada a open().")
      sys.exit(0)
    }

    try {
      val statement = connection.createStatement()
      if (sql.startsWith("select ")) {
        val resultSet = statement.executeQuery(sql)
        val rsmd = resultSet.getMetaData
        val numColumns = rsmd.getColumnCount
        val columnsType = new Array[Int](numColumns + 1)
        columnsType(0) = 0
        1 to numColumns foreach (i => columnsType(i) = rsmd.getColumnType(i))

        val queue = mutable.Queue[Seq[Double]]()
        while (resultSet.next()) {
          val seq = 1 to numColumns map { i =>
            //            val s = columnsType(i) match {
            //              case java.sql.Types.BOOLEAN | java.sql.Types.DATE | java.sql.Types.TIMESTAMP | java.sql.Types.TINYINT | java.sql.Types.SMALLINT | java.sql.Types.INTEGER | java.sql.Types.BIGINT | java.sql.Types.CHAR | java.sql.Types.VARCHAR => resultSet.getString(i)
            //              case java.sql.Types.NVARCHAR => resultSet.getNString(i)
            //              case java.sql.Types.FLOAT | java.sql.Types.NUMERIC | java.sql.Types.DOUBLE => "%2.2f".format(resultSet.getDouble(i))
            //              case _ => resultSet.getString(i)
            //            }
            resultSet.getDouble(i)
          }
          queue.enqueue(seq)
        }
        Right(queue)
      } else {
        val rowCount = statement.execute(sql)
        Left(rowCount)
      }
    } catch {
      case e: Throwable => e.printStackTrace
        println("\nProblems executing SQL query '" + sql + "' in: " + dbCopy + ".")
        sys.exit(0)
    }
  }

  private def copyDb {
    //    println("Copying " + dbCopy + " to " + dbOriginal + "...")
    FileUtils.copyFile(dbCopy, dbOriginal)
    //    println(" " + dbCopy + " to " + dbOriginal + " copied!")
  }

  def close {
    copyDb
    //    println("Deleting " + dbCopy + "...")
    dbCopy.delete()
    //    println(" " + dbCopy + " deleted!")
    connection.close()
    connection = null
  }
}

object DatasetTest extends App {
  //load patterns
  val patts = Datasets.patternsFromSQLite("/home/davi/wcs/ucipp/uci/")("iris").right.get

  //reorder patterns as queries
  val shuffled = patts.drop(5) ++ patts.take(4)

  //write queries
  val d = Dataset("/home/davi/wcs/ucipp/uci/")("iris")
  d.open(debug = true)
  d.writeQueries(RandomSampling(patts), 4, 9)
  d.close

  //load queries as patterns
  val qpatts = ALDatasets.queriesFromSQLite("/home/davi/wcs/ucipp/uci/")("iris")(4, 9).right.get
  qpatts foreach println

}