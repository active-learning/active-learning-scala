package svmalk.libsvm;import svmalk.weka.core.InstanceContainer;import weka.core.Utils;public class SvmLibPair implements InstanceContainer {    private svm_node[] nodes = null;    private double classVal = Double.NaN;    private double weight = 1.0;    private IntegerContainer index;    public SvmLibPair(svm_node[] n,                      double cls,                      IntegerContainer indx) {        this.nodes = n;        this.classVal = cls;        this.index = indx;    }    public static double distance(svm_node[] nodes1, svm_node[] nodes2) throws Exception {        double res = 0;        Object[] ans = SvmLibPair.mergeAndSort2Instances(nodes1, nodes2);        int[] ids = (int[]) ans[0];        double[][] vals = (double[][]) ans[1];        for (int i = 0; ids[i] != -1; i++) {            res += Math.pow(vals[0][i] - vals[1][i], 2);        }        res = Math.sqrt(res);        return res;    }    public static svm_node[] addition(svm_node[] nodes1, svm_node[] nodes2, double factor) throws Exception {        double val;        Object[] ans = SvmLibPair.mergeAndSort2Instances(nodes1, nodes2);        int[] ids = (int[]) ans[0];        double[][] vals = (double[][]) ans[1];        int size = 0;        for (int i = 0; ids[i] != -1; i++) {            size++;        }        svm_node[] res = new svm_node[size];        for (int i = 0; ids[i] != -1; i++) {            val = vals[0][i] + factor * vals[1][i];            res[i] = new svm_node();            res[i].index = ids[i];            res[i].value = val;        }        return res;    }    public static svm_node[] average(svm_node[] nodes1, svm_node[] nodes2) throws Exception {        double val;        Object[] ans = SvmLibPair.mergeAndSort2Instances(nodes1, nodes2);        int[] ids = (int[]) ans[0];        double[][] vals = (double[][]) ans[1];        int size = 0;        for (int i = 0; ids[i] != -1; i++) {            size++;        }        svm_node[] res = new svm_node[size];        for (int i = 0; ids[i] != -1; i++) {            val = (vals[0][i] + vals[1][i]) * 0.5;            res[i] = new svm_node();            res[i].index = ids[i];            res[i].value = val;        }        return res;    }    public static double scalarProduct(svm_node[] nodes1, svm_node[] nodes2) throws Exception {        double res = 0;        Object[] ans = SvmLibPair.mergeAndSort2Instances(nodes1, nodes2);        int[] ids = (int[]) ans[0];        double[][] vals = (double[][]) ans[1];        for (int i = 0; ids[i] != -1; i++) {            res += vals[0][i] * vals[1][i];        }        return res;    }    public static boolean isEqual(svm_node[] nodes1, svm_node[] nodes2) {        int i;        if (nodes1.length != nodes2.length) {            return false;        }        for (i = 0; i < nodes1.length - 1; i++) {            if (nodes1[i].index != nodes2[i].index) {                return false;            }            if (!Utils.eq(nodes1[i].value, nodes2[i].value)) {                return false;            }        }        return true;    }    public static Object[] mergeAndSort2Instances(svm_node[] s1,                                                  svm_node[] s2) throws Exception {        int indx = -1, lastId = -1, itr = 0;        int classIndx;        int[] currId = new int[2];        svm_node[][] nodes = new svm_node[2][];        nodes[0] = new svm_node[s1.length - 1];        nodes[1] = new svm_node[s2.length - 1];        System.arraycopy(s1, 0, nodes[0], 0, nodes[0].length);        System.arraycopy(s2, 0, nodes[1], 0, nodes[1].length);        int[] idPlaces = new int[2];        int[] valPlaces = new int[2];        idPlaces[0] = idPlaces[1] = 0;        valPlaces[0] = valPlaces[1] = 0;        int totalSize = nodes[0].length - 1 + nodes[1].length - 1 + 1; // one more for marking the end        int[] ids = new int[totalSize];        double[][] vals = new double[2][];        for (indx = 0; indx < 2; indx++) {            vals[indx] = new double[totalSize];        }        while ((idPlaces[0] < nodes[0].length) || (idPlaces[1] < nodes[1].length)) {            if (lastId == -1) {                // indx and lastId values are invalid                if (idPlaces[0] < nodes[0].length) {                    currId[0] = nodes[0][idPlaces[0]++].index;                } else {                    // no more values                    currId[0] = Integer.MAX_VALUE;                }                if (idPlaces[1] < nodes[1].length) {                    currId[1] = nodes[1][idPlaces[1]++].index;                } else {                    if (currId[0] == Integer.MAX_VALUE) continue;                    currId[1] = Integer.MAX_VALUE;                }            } else {                // indx holds the array that we are running on currently                // lastId is the smallest value in the second array                if (idPlaces[indx] < nodes[indx].length) {                    currId[indx] = nodes[indx][idPlaces[indx]++].index;                } else {                    if (currId[(indx + 1) % 2] == Integer.MAX_VALUE) continue;                    currId[indx] = Integer.MAX_VALUE;                }                currId[(indx + 1) % 2] = lastId;            }            if (currId[0] == currId[1]) {                ids[itr] = currId[0];                for (indx = 0; indx < 2; indx++) {                    vals[indx][itr] = nodes[indx][valPlaces[indx]++].value;                }                lastId = -1;            } else {                indx = (currId[0] < currId[1]) ? 0 : 1;                ids[itr] = currId[indx];                vals[indx][itr] = nodes[indx][valPlaces[indx]++].value;                vals[(indx + 1) % 2][itr] = 0;                lastId = currId[(indx + 1) % 2];            }            itr++;        }        // mark the end        ids[itr] = -1;        Object[] ans = new Object[2];        ans[0] = ids;        ans[1] = vals;        return ans;    }    public svm_node[] getNodes() {        return this.nodes;    }    public void setNodes(svm_node[] n) {        this.nodes = n;    }    public double classValue() {        return this.classVal;    }    public void setClassValue(double value) {        this.classVal = value;    }    public double weight() {        return this.weight;    }    public void setWeight(double w) {        this.weight = w;    }    public int getIndex() {        return this.index.getValue();    }    public void setIndex(int indx) {        this.index.setValue(indx);    }//    public Instance toInstance(Instances dataSet) throws Exception {//        int i;//        int numAtt = this.nodes.length - 1;//        boolean isSparse = false;//        if (numAtt + 1 != dataSet.numAttributes()) {//            throw new Exception("toInstance - number of attributes is different. numAtt+1=" + (numAtt + 1) + " dataset.numAtt=" + dataSet.numAttributes());//            //isSparse = true;//        }//        int classIndx = dataSet.classIndex();//        Instance2 ins;//        if (!isSparse) {//            int largestAttIndx = nodes[numAtt - 1].index - 1;//            if (classIndx > largestAttIndx) {//                largestAttIndx = classIndx;//            }//            double[] values = new double[largestAttIndx + 1];//            for (i = 0; i < values.length; i++) {//                values[i] = 0;//            }//            for (i = 0; i < numAtt; i++) {//                if (nodes[i].index - 1 == classIndx) throw new Exception("toInstance - regular att with classIndx");//                values[nodes[i].index - 1] = nodes[i].value;//            }//            values[classIndx] = this.classVal;//            ins = new Instance2(weight, values);//        } else {////            FastVector ids = new FastVector();////            FastVector vals = new FastVector();////            for (i=0; i<numAtt; i++) {////                if (nodes[i].index-1 == classIndx) throw new Exception("toInstance - regular att with classIndx");////                ids.addElement(new Integer(nodes[i].index-1));////                vals.addElement(new Double(nodes[i].value));////            }////            ids.addElement(new Integer(classIndx));////            vals.addElement(new Double(this.classVal));////            SparseInstance sIns = new SparseInstance();////            sIns.setIdsVals(ids, vals);////            ins = sIns;//            ins = null;//        }//        ins.setDataset(dataSet);//        ins.setIndex(index.getValue());//        return ins;//    }    public String toString() {        int i;        StringBuffer str = new StringBuffer();        str.append("(");        for (i = 0; i < this.nodes.length; i++) {            str.append("" + this.nodes[i].index + ":" + this.nodes[i].value + ", ");        }        str.append(") class:" + this.classVal);        str.append(" index: " + this.index.getValue());        return str.toString();    }} 